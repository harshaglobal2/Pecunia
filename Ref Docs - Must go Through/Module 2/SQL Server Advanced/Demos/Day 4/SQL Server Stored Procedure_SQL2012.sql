--Creating a simple stored procedure
use northwind
create proc usp_myproc as select * from customers 
exec usp_myproc
execute usp_myproc

CREATE PROC usp_AddTwoIntegers
 @FirstNumber int = 5,
   @SecondNumber int,
   @Answer varchar(30) OUTPUT as
   Declare @sum int
   Set @sum = @FirstNumber + @SecondNumber
   Set @Answer = 'The answer is '
    + convert(varchar,@sum)
   Return @sum
      Declare @a int, @b int, @c varchar(30)
Select @a = 1, @b = 2
Exec usp_AddTwoIntegers @a, @b, @c OUTPUT
Select @c

Use northwind

CREATE PROCEDURE usp_ProductCountByCategory (
      @i_catid  INT ,
      @o_Prodcount INT OUT
   )
AS
BEGIN
     IF @i_catid is NULL OR @i_catid < 0 
         return -1
     SELECT  @o_Prodcount=count(ProductID) from Products
      WHERE CategoryID=@i_catid
END 

DECLARE  @prodcount   INT
EXEC  usp_ProductCountByCategory  1, @prodcount  OUT
select @prodcount
select * from Products

CREATE PROC procEmployeeList
AS
SELECT EmployeeID, LastName, FirstName, Address,
City,  HomePhone 
FROM Employees
--execute the stored procedure

procEmployeeList
--or you can specify 
execute procEmployeeList
exec procEmployeeList

--stored procedure with input parameters
/*Input parameter values can be passed to a stored procedure when you execute
it, as long as the stored procedure has declared them and set their data type. If
you have more than one input parameter, separate the values with commas.
The following procedure uses the input parameter @City in its WHERE clause
to limit the number of employee records returned:*/
CREATE PROC procEmployeeListByCity
@City varchar(25)
AS
SELECT EmployeeID, LastName, FirstName, Address,
City,  HomePhone 
FROM Employees
WHERE City = @City

EXEC procEmployeeListByCity @City = 'Seattle'
--by position 
EXECUTE procEmployeeListByCity 'Seattle'
/*If you have more than one parameter, separate them with commas. If you
execute the stored procedure by position, the parameters must be supplied in
the order in which they are declared*/


/*Output parameters are used when you want to return a valuesuch as the new
identity column for an inserted record. Declare them normally, with the
OUTPUT keyword at the end of the declaration statement:*/

CREATE PROC procEmployeeInsert
@LastName varchar(50) = NULL,
@FirstName varchar(50) = NULL,
@Address varchar(50) = NULL,
@City varchar(25) = NULL,


@HomePhone varchar(10) = NULL,
@EmployeeID int = NULL OUTPUT
AS
INSERT INTO Employees(
LastName, FirstName, Address,
City,  
HomePhone)
VALUES(
@LastName, @FirstName, @Address,
@City,
@HomePhone)
SELECT @EmployeeID = @@IDENTITY

DECLARE @NewID int
EXEC procEmployeeInsert
@LastName = 'Badenov',
@FirstName = 'Boris',
@Address = '1 Rotten Row',
@City = 'Frostbite Falls',

@EmployeeID = @NewID OUTPUT
SELECT @NewID AS NewEmpID

--or
SELECT @@IDENTITY As NewID
/*The @@IDENTITY function can only be relied upon if it immediately
follows the INSERT statement. The value returned by @@IDENTITY is
always the identity value that was generated by the last statement executed in
that connection.*/


/*one more example of output parameter
use AdventureWorks2012
CREATE PROCEDURE dbo.GetCountByLastName (
    @LastName NVARCHAR(50),
    @LastNameCount INT OUTPUT )
AS
SELECT @LastNameCount = COUNT(*)
FROM Person.Contact
WHERE LastName = @LastName
--execute the procedure
DECLARE @TheCount INT

EXEC dbo.GetCountByLastName 
    @LastName = 'Alexander',
    @LastNameCount = @TheCount OUTPUT

SELECT TheCount = @TheCount
GO
*/
/*stored procedure with encryption */
cREATE PROCEDURE encrypt_this
WITH ENCRYPTION 
AS
SELECT * 
FROM  Customers
GO

EXEC sp_helptext encrypt_this

/*With recompile*/
use AdventureWorks2012
CREATE PROCEDURE dbo.uspProductByVendor @Name varchar(30) = '%'
WITH RECOMPILE
AS
    SET NOCOUNT ON;
    SELECT v.Name AS 'Vendor name', p.Name AS 'Product name'
    FROM Purchasing.Vendor AS v 
    JOIN Purchasing.ProductVendor AS pv 
      ON v.BusinessEntityID = pv.BusinessEntityID 
    JOIN Production.Product AS p 
      ON pv.ProductID = p.ProductID
    WHERE v.Name LIKE @Name;


	USE AdventureWorks2012;
GO
EXECUTE HumanResources.uspGetAllEmployees
 WITH RECOMPILE;
GO
/*with sp_recompile*/
USE AdventureWorks2012;
GO
EXEC sp_recompile N'HumanResources.uspGetAllEmployees';
GO



/*stored procedure with cursor */
use northwind
CREATE PROCEDURE uspRankCustomers
AS
DECLARE @CustomerId int
DECLARE @OrderTotal money
DECLARE @RankingId int
DECLARE curCustomer CURSOR FOR
SELECT CustomerId, OrderTotal FROM vwCustomerOrderSummary
OPEN curCustomer
FETCH NEXT FROM curCustomer INTO @CustomerId, @OrderTotal
WHILE @@FETCH_STATUS = 0
BEGIN
IF @OrderTotal = 0 SET @RankingId = 1
ELSE IF @OrderTotal < 100 SET @RankingId = 2
ELSE IF @OrderTotal < 1000 SET @RankingId = 3
ELSE IF @OrderTotal < 10000 SET @RankingId = 4
ELSE SET @RankingId = 5
UPDATE Customer
SET RankingId = @RankingId
WHERE CustomerId = @CustomerId
FETCH NEXT FROM curCustomer INTO @CustomerId, @OrderTotal
END
CLOSE curCustomer
DEALLOCATE curCustomer

/*return value*/
CREATE PROC dbo.usp_TestReturn (@InValue int)
AS
Return @Invalue
GO
/*All it does is use the RETURN statement to send back the value that was passed in.
 Note that executing a RETURN statement causes a stored procedure to stop executing and 
 return control back to the calling program. This is often used to test for error
  conditions and stop processing if one is found. The following script calls 
  the TestReturn stored procedure:*/


DECLARE @ReturnValue INT
EXEC @ReturnValue = usp_TestReturn 3
SELECT ReturnValue=@ReturnValue
/*extra example */
use AdventureWorks2012
CREATE PROCEDURE Sales.uspGetEmployeeSalesYTD
@SalesPerson nvarchar(50),
@SalesYTD money OUTPUT
AS  

    SET NOCOUNT ON;
    SELECT @SalesYTD = SalesYTD
    FROM Sales.SalesPerson AS sp
    JOIN HumanResources.vEmployee AS e ON e.BusinessEntityID = sp.BusinessEntityID
    WHERE LastName = @SalesPerson;
RETURN
GO

-- Declare the variable to receive the output value of the procedure.
DECLARE @SalesYTDBySalesPerson money;
-- Execute the procedure specifying a last name for the input parameter
-- and saving the output value in the variable @SalesYTDBySalesPerson
EXECUTE Sales.uspGetEmployeeSalesYTD
    N'Blythe', @SalesYTD = @SalesYTDBySalesPerson OUTPUT;
-- Display the value returned by the procedure.
PRINT 'Year-to-date sales for this employee is ' + 
    convert(varchar(10),@SalesYTDBySalesPerson);
GO



